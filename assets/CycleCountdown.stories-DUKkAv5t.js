import{r as i,j as e,u as x}from"./index-RY1cFico.js";import"./dialog-DlLYfIg7.js";import{d as p}from"./dayjs.min-0Xv1M-S0.js";import{C as y}from"./Countdown-Cyxc4eM9.js";import{C as S}from"./CycleProgress-C6_NA_Va.js";import"./index-BUFVoi7r.js";import"./bundle-mjs-yGZq-iow.js";function a({expiresAt:n,totalDuration:t,size:s="md",overrideSize:r,color:f="#00A321",strokeWidthRem:j=.35,isStatic:g,terminalColor:k="#8B0000",terminalPercentage:l,formatter:v,onExpire:d,onUpdate:c,data:b,className:o}){const[m,u]=i.useState(t!==0?p(n).diff(p(),"second")/t*100:0);return e.jsx(S,{size:s,overrideSize:r,percentage:l&&m===0?l:m,color:l&&m===0?k:f,strokeWidthRem:j,data:b,className:{root:o==null?void 0:o.root,children:o==null?void 0:o.countdownWrapper},children:e.jsx(y,{isStatic:g,expiresAt:n,formatter:v,onExpire:()=>{d==null||d(),u(0)},onUpdate:h=>{c==null||c(h),u(t!==0?h/t*100:0)},className:{root:o==null?void 0:o.countdown}})})}const T=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10})},R=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10,isStatic:!0})},W=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10,size:"sm",strokeWidthRem:.2})},P=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10,formatter:t=>`${t} s`})},I=()=>{const[n,t]=i.useState(!1),s=new Date;return s.setSeconds(s.getSeconds()+10),e.jsxs("div",{children:[e.jsx(a,{expiresAt:s,totalDuration:10,onExpire:()=>{t(!0)}}),"onExpire function executed: ",n?"yes":"no"]})},O=()=>{const n=i.useMemo(()=>{const r=new Date;return r.setSeconds(r.getSeconds()+10),r},[]),[t,s]=i.useState(0);return e.jsxs("div",{children:["This countdown uses the onUpdate function to update a state value. Note that we need to use a useMemo hook for the memoization of the time variable, otherwise the countdown will be re-rendered every second. Also, the time will not be updated on expiration and will therefore stay at 1 in the end.",e.jsx(a,{expiresAt:n,totalDuration:10,onUpdate:r=>{s(r)}}),"Updated value: ",t]})},U=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10,color:"#FF0000",strokeWidthRem:.6,className:{root:"bg-blue-300",countdown:"font-bold"}})},X=()=>{const n=new Date;return n.setSeconds(n.getSeconds()+10),e.jsx(a,{expiresAt:n,totalDuration:10,terminalColor:"#FF0000",terminalPercentage:100})};function w(n){const t={code:"code",li:"li",p:"p",ul:"ul",...x(),...n.components};return e.jsxs(e.Fragment,{children:[`
`,e.jsxs("div",{className:"prose prose-sm max-w-none",children:[e.jsxs(t.p,{className:"ladle-markdown",children:["The ",e.jsx(t.code,{className:"ladle-markdown",children:"CycleCountdown"})," component provides a visual circular countdown timer with animated progress indication and extensive customization options. It combines the functionality of a countdown timer with an intuitive circular progress visualization, offering precise visual feedback for time-sensitive interfaces."]}),e.jsx(t.p,{className:"ladle-markdown",children:"Use this component when you need to:"}),e.jsxs(t.ul,{className:"ladle-markdown",children:[`
`,e.jsx(t.li,{className:"ladle-markdown",children:"Create visually engaging countdown timers with circular progress indication"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"Display countdown progress with immediate visual feedback for users"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"Implement time-limited activities with clear visual time remaining indicators"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"Build quiz interfaces, timed challenges, or deadline visualizations"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"Provide customizable sizing and styling for different interface contexts"}),`
`]}),e.jsx(t.p,{className:"ladle-markdown",children:"The component supports circular progress visualization, multiple size variants, customizable colors and stroke widths, terminal state styling for expiration, complete countdown functionality with callbacks, and comprehensive styling options for all visual elements."}),e.jsx(t.p,{className:"ladle-markdown",children:"The props for the CycleCountdown component are as follows:"}),e.jsxs(t.ul,{className:"ladle-markdown",children:[`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param expiresAt - Date when the countdown should expire"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param totalDuration - Total duration of the countdown in seconds, which is needed to compute the progress in percent"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param size - Size of the progress bar, can be 'sm' or 'md'"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param overrideSize - Optional override for the size of the progress bar"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param color - Color of the progress bar (static for the moment)"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param strokeWidthRem - Width of the progress bar. For small size, a smaller value is recommended"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param isStatic - If true, the countdown will not be running, but instead show the initial value. However, as the end value is given by a date, reloading can modify the displayed countdown value"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param terminalColor - Color of the progress bar when the countdown is expired (total Duration 0 or expiration in the past)"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param terminalPercentage - Percentage of the progress bar when the countdown is expired (totalDuration 0 or expiration in the past)"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param formatter - Function to format the countdown value"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param onExpire - Function that is executed when the countdown expires"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param onUpdate - Function that is executed when the countdown is updated (not when it expires)"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param data - Optional data object that can be used for testing (e.g. data-test or data-cy)"}),`
`,e.jsx(t.li,{className:"ladle-markdown",children:"@param className - Optional className object allows you to override the default styling"}),`
`]})]}),`
`,`
`]})}function D(n={}){const{wrapper:t}={...x(),...n.components};return t?e.jsx(t,{...n,children:e.jsx(w,{...n})}):w(n)}D.storyName="Readme";typeof window<"u"&&window.document&&window.document.createElement&&document.documentElement.setAttribute("data-storyloaded","");export{T as Default,I as Expiration,P as Formatter,D as MDXContent,W as Small,R as Static,U as Styled,X as TerminalSettings,O as Updating};
